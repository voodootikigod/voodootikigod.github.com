<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: recursion | Voodoo Tiki God]]></title>
  <link href="http://voodootikigod.github.com/blog/categories/recursion/atom.xml" rel="self"/>
  <link href="http://voodootikigod.github.com/"/>
  <updated>2013-02-16T21:14:22-05:00</updated>
  <id>http://voodootikigod.github.com/</id>
  <author>
    <name><![CDATA[Chris Williams]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Real Y-Combinator (in JavaScript)]]></title>
    <link href="http://voodootikigod.github.com/the-real-y-combinator-in-javascript/"/>
    <updated>2009-08-31T00:00:00-04:00</updated>
    <id>http://voodootikigod.github.com/the-real-y-combinator-in-javascript</id>
    <content type="html"><![CDATA[<p>I want to get to this eventually in <a href="http://www.nakedjavascript">Naked JavaScript</a>, but for the time being I wanted to share a great little code bit with you in JavaScript. Also given <a href="http://paulbarry.com/articles/2009/08/30/tail-call-optimization">Paul's recent post</a>, I decided it would be good to continue the functional JavaScript by providing a different, way off accomplishing tail call optimization. As I <a href="http://voodootikigod.com/paul-barry-shows-how-to-accomplish-tail-call">mentioned previously</a>, JavaScript has a strict limit on the call stack of around 1,000 entries (varies based on interpreter implementation) which commonly prevents any level of deep recursion, especially if writing portable JavaScript for multiple browsers. Paul's method of leveraging an accumulator wrapped in a closure is a great method for accomplishing a recursive task in a stack or memory constrained environment. So great in fact that the basic pattern of detecting repetition and translating it to a linear fashion is very similar to the underpinnings of what <a href="https://wiki.mozilla.org/JavaScript:TraceMonkey">TraceMonkey</a> automatically accomplishes using <a href="http://www.ics.uci.edu/%7Efranz/Site/pubs-pdf/ICS-TR-06-16.pdf">Trace Trees</a>.</p>


<p>From Paul's description of the problem at hand, we are trying to find the odds of becoming the next&nbsp;mega-millionare. The following is the imperative solution provided by Paul using a variable to accumulate the odds at any given step in the process as the multiple of the previous value and the new expression result.</p>


<p><script src="https://gist.github.com/178832.js"></script></p>


<p>Paul presents the conversion of this code segment to a simple recursive function that will help us to find the value of by calling the function over and over with varying values defined within the function until a termination clause is reached. In this case the termination clause is when the variable n equals the value 0.</p>


<p><script src="https://gist.github.com/178842.js"></script></p>


<p>With the basic code from those two examples and a utility for the spell books of lambda calculus, we can actually create a recursive function and then apply it to the exercise. Mind you that this will still suffer from the aforementioned call stack limitations placed on the JavaScript VM due to its applicative nature, and realistically there are far better ways for obtaining the same result (one of which shown at the end), but to hell with all that.</p>


<p>By using a technique known as <a href="http://en.wikipedia.org/wiki/Fixed_point_combinator">Fixed Point Combinator</a>, and specifically a <a href="http://en.wikipedia.org/wiki/Fixed_point_combinator#Y_combinator">Y-Combinator</a>&nbsp;we will not on obtain the result but build recursion without using a named function. To begin, a Fixed Point Combinator is a special type of higher order function that has the unique transitive property that for any function <strong>F </strong>and value <strong>V</strong>, the value of the Y-Combinator function <strong>G </strong>when passed the parameter <strong>F</strong> will return the value <strong>V</strong> which is the same value as when <strong>V</strong> is passed to <strong>F</strong>. Lost? Lets look at this description as a the transitive function definition:</p>


<p>[code]F(G(F)) == G(F)[/code]</p>


<p>The definition of a combinator relies on the lazy evaluation of functions in order to allow a function to be defined in terms of itself, often times referred to as <em>anonymous recursion</em>. This requires a deep understanding or interest in <a href="http://en.wikipedia.org/wiki/Lambda_calculus">lambda calculus</a> and this function is deviously complex and compact. For more details about a Y-Combinator, which is a specific formula of a Fixed Point Combinator, <a href="http://www.ece.uc.edu/~franco/C511/html/Scheme/ycomb.html">look here</a>.&nbsp;Let us look at it as a JavaScript function:</p>


<p><script src="https://gist.github.com/178862.js"></script></p>


<p>This definition is from <a href="http://blog.jcoglan.com/2008/01/10/deriving-the-y-combinator/">The If Works</a> and happens to be one of the most compact, but readable implementations I have seen and it even slips a couple extra JavaScript specific enhancements to make it even more flexible. The definition of this function is near exact to the formulaic definition described in Scheme from the link above with one key advantage. Using the <em><a href="https://developer.mozilla.org/En/Core_JavaScript_1.5_Reference/Functions_and_function_scope/arguments">arguments</a></em>&nbsp;object in combination with the <em><a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Function/apply">apply</a></em> function that is available on functions, we can make this more flexible than the one described in <a href="http://javascript.crockford.com/little.html">The Little JavaScripter</a> by <a href="http://javascript.crockford.com/">Douglas Crockford</a>&nbsp;by allowing it to handle any number of arguments passed in.</p>


<p>With this definition of a Y-Combinator, let us revise the original problem set using the code from the recursive definition. The most important part that we can take from the recursive definition is the conditional logic, in fact that is all we will be taking. The Y-Combinator version of this looks like this:</p>


<p><script src="https://gist.github.com/178878.js"></script></p>


<p>Which looks similar to the recursive definition and it really should, because all we have done is create recursion using anonymous functions instead of named functions. As I said earlier, this method is most likely not going to win you fame or fortune (but if it does I claim 5% of the winnings), &nbsp;it is however a great example of the functional capabilities of the JavaScript programming language. All that said, here is probably the most terse definition of this function I could devise:</p>


<p><script src="https://gist.github.com/178887.js"></script></p>

]]></content>
  </entry>
  
</feed>
